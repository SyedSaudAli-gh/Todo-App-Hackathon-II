# Data Model: Phase II Todo Management

**Feature**: Phase II Todo Management
**Branch**: `001-phase-ii-todos`
**Date**: 2026-01-06
**Status**: Complete

## Overview

This document defines the persistent data model for the Phase II Todo Management feature using SQLModel (SQLAlchemy + Pydantic). The model supports all CRUD operations defined in the feature specification and follows Phase II Constitution requirements for persistent storage.

## Entity: Todo

### Purpose

The Todo entity represents a single task or item that a user needs to complete. It is the core entity of the application and supports all user stories defined in spec.md.

### SQLModel Schema

```python
from datetime import datetime
from typing import Optional
from sqlmodel import Field, SQLModel

class Todo(SQLModel, table=True):
    """
    Todo entity for persistent storage in Neon PostgreSQL.

    Supports:
    - User Story 1 (P1): Create and View Todos
    - User Story 2 (P2): Mark Todos Complete
    - User Story 3 (P3): Update Todo Details
    - User Story 4 (P4): Delete Todos
    """
    __tablename__ = "todos"

    # Primary Key
    id: Optional[int] = Field(default=None, primary_key=True)

    # Required Fields
    title: str = Field(
        min_length=1,
        max_length=200,
        description="Todo title (required, 1-200 characters)"
    )

    # Optional Fields
    description: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Todo description (optional, max 2000 characters)"
    )

    # Status
    completed: bool = Field(
        default=False,
        description="Completion status (true = completed, false = active)"
    )

    # Timestamps
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Creation timestamp (UTC)"
    )

    updated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Last update timestamp (UTC)"
    )
```

### Field Specifications

#### id (Primary Key)
- **Type**: Integer (auto-increment)
- **Constraints**: Primary key, unique, not null
- **Purpose**: Unique identifier for each todo
- **Rationale**: Auto-increment integers are simpler than UUIDs for MVP, provide natural ordering
- **Phase II Compliance**: Uses database primary keys (no positional list indexing)

#### title (Required)
- **Type**: String
- **Constraints**:
  - Required (not null)
  - Minimum length: 1 character (after trimming)
  - Maximum length: 200 characters
- **Validation**: Enforced at database, API (Pydantic), and frontend levels
- **Purpose**: Primary description of the todo item
- **Spec Reference**: FR-007 (validation rules)

#### description (Optional)
- **Type**: String (nullable)
- **Constraints**:
  - Optional (can be null)
  - Maximum length: 2000 characters
- **Validation**: Enforced at database, API (Pydantic), and frontend levels
- **Purpose**: Additional details about the todo item
- **Spec Reference**: FR-008 (validation rules)

#### completed (Status)
- **Type**: Boolean
- **Constraints**: Not null, defaults to false
- **Purpose**: Tracks completion status for User Story 2 (P2)
- **Spec Reference**: FR-004 (mark complete/incomplete)

#### created_at (Timestamp)
- **Type**: DateTime (UTC)
- **Constraints**: Not null, auto-generated on insert
- **Purpose**: Tracks when todo was created
- **Spec Reference**: FR-013 (timestamp tracking)
- **Usage**: Enables sorting by creation date (newest first per spec.md)

#### updated_at (Timestamp)
- **Type**: DateTime (UTC)
- **Constraints**: Not null, auto-updated on modification
- **Purpose**: Tracks when todo was last modified
- **Spec Reference**: FR-013 (timestamp tracking)
- **Usage**: Enables audit trail and conflict detection

### Database Table Definition

```sql
-- Generated by Alembic migration
CREATE TABLE todos (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    description VARCHAR(2000),
    completed BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index for sorting by creation date (newest first)
CREATE INDEX idx_todos_created_at ON todos(created_at DESC);

-- Index for filtering by completion status
CREATE INDEX idx_todos_completed ON todos(completed);
```

### Indexes

#### idx_todos_created_at
- **Columns**: created_at (descending)
- **Purpose**: Optimize sorting for "newest first" display (spec.md requirement)
- **Query**: `SELECT * FROM todos ORDER BY created_at DESC`

#### idx_todos_completed
- **Columns**: completed
- **Purpose**: Optimize filtering by completion status (future enhancement)
- **Query**: `SELECT * FROM todos WHERE completed = false`

## Pydantic Schemas (Request/Response)

### TodoCreate (Request)

```python
from pydantic import BaseModel, Field, field_validator

class TodoCreate(BaseModel):
    """Request schema for creating a new todo."""

    title: str = Field(
        min_length=1,
        max_length=200,
        description="Todo title (required)"
    )

    description: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Todo description (optional)"
    )

    @field_validator('title')
    @classmethod
    def title_must_not_be_empty(cls, v: str) -> str:
        """Validate that title is not empty or whitespace only."""
        if not v or not v.strip():
            raise ValueError('Title cannot be empty or whitespace only')
        return v.strip()

    @field_validator('description')
    @classmethod
    def description_strip_whitespace(cls, v: Optional[str]) -> Optional[str]:
        """Strip whitespace from description if provided."""
        if v:
            return v.strip() if v.strip() else None
        return None
```

### TodoUpdate (Request)

```python
class TodoUpdate(BaseModel):
    """Request schema for updating an existing todo."""

    title: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=200,
        description="Updated title (optional)"
    )

    description: Optional[str] = Field(
        default=None,
        max_length=2000,
        description="Updated description (optional)"
    )

    completed: Optional[bool] = Field(
        default=None,
        description="Updated completion status (optional)"
    )

    @field_validator('title')
    @classmethod
    def title_must_not_be_empty(cls, v: Optional[str]) -> Optional[str]:
        """Validate that title is not empty if provided."""
        if v is not None:
            if not v or not v.strip():
                raise ValueError('Title cannot be empty or whitespace only')
            return v.strip()
        return None
```

### TodoResponse (Response)

```python
from datetime import datetime

class TodoResponse(BaseModel):
    """Response schema for todo operations."""

    id: int
    title: str
    description: Optional[str]
    completed: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # Enable ORM mode for SQLModel compatibility
```

### TodoListResponse (Response)

```python
class TodoListResponse(BaseModel):
    """Response schema for listing todos."""

    todos: list[TodoResponse]
    total: int

    # Future pagination support (Phase III)
    # page: int
    # page_size: int
    # has_next: bool
```

## Validation Rules

### Title Validation
- **Required**: Yes (cannot be null or empty)
- **Min Length**: 1 character (after trimming whitespace)
- **Max Length**: 200 characters
- **Trimming**: Automatically trim leading/trailing whitespace
- **Error Message**: "Title is required" (empty), "Title cannot exceed 200 characters" (too long)
- **Spec Reference**: FR-007, spec.md Validation Rules

### Description Validation
- **Required**: No (can be null)
- **Max Length**: 2000 characters
- **Trimming**: Automatically trim leading/trailing whitespace
- **Null Handling**: Empty string after trimming becomes null
- **Error Message**: "Description cannot exceed 2000 characters" (too long)
- **Spec Reference**: FR-008, spec.md Validation Rules

### Completed Validation
- **Required**: Yes (defaults to false)
- **Type**: Boolean only (true or false)
- **Error Message**: "Completed must be a boolean value"
- **Spec Reference**: FR-004, spec.md Validation Rules

## State Transitions

### Todo Lifecycle

```
[Created] → [Active] → [Completed] → [Active] (toggle)
                ↓           ↓
            [Updated]   [Updated]
                ↓           ↓
            [Deleted]   [Deleted]
```

### Valid Transitions

1. **Create**: null → Active (completed=false)
2. **Mark Complete**: Active → Completed (completed=true)
3. **Mark Incomplete**: Completed → Active (completed=false)
4. **Update**: Active/Completed → Active/Completed (title, description, completed can change)
5. **Delete**: Active/Completed → Deleted (hard delete, no soft delete in Phase II)

### Timestamp Behavior

- **created_at**: Set once on creation, never modified
- **updated_at**: Set on creation, updated on every modification (title, description, completed changes)

## Database Migrations

### Initial Migration (001_create_todos_table.py)

```python
"""Create todos table

Revision ID: 001
Revises:
Create Date: 2026-01-06
"""
from alembic import op
import sqlalchemy as sa

def upgrade() -> None:
    """Create todos table with indexes."""
    op.create_table(
        'todos',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('title', sa.String(length=200), nullable=False),
        sa.Column('description', sa.String(length=2000), nullable=True),
        sa.Column('completed', sa.Boolean(), nullable=False, server_default='false'),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.PrimaryKeyConstraint('id')
    )

    # Create indexes
    op.create_index('idx_todos_created_at', 'todos', ['created_at'], unique=False, postgresql_ops={'created_at': 'DESC'})
    op.create_index('idx_todos_completed', 'todos', ['completed'], unique=False)

def downgrade() -> None:
    """Drop todos table and indexes."""
    op.drop_index('idx_todos_completed', table_name='todos')
    op.drop_index('idx_todos_created_at', table_name='todos')
    op.drop_table('todos')
```

## Relationships

### Phase II (MVP)
- **No relationships**: Single table design for simplicity
- **No foreign keys**: Todos are independent entities

### Phase III+ (Future)
Potential relationships to consider:
- **User → Todos**: One-to-many (when authentication added)
- **Category → Todos**: Many-to-many (when categories added)
- **Tag → Todos**: Many-to-many (when tags added)

## Data Integrity

### Constraints
- **Primary Key**: Ensures unique identification
- **NOT NULL**: title, completed, created_at, updated_at must have values
- **Length Limits**: Prevents excessively large data
- **Boolean Type**: Ensures completed is always true or false

### Transaction Handling
- **Create**: Single INSERT, atomic
- **Update**: Single UPDATE, atomic
- **Delete**: Single DELETE, atomic
- **Bulk Operations**: Not supported in Phase II (future enhancement)

### Concurrency
- **Strategy**: Last write wins (optimistic concurrency)
- **Rationale**: Single-user system in Phase II, conflicts unlikely
- **Phase III**: Consider adding version field for optimistic locking

## Performance Considerations

### Query Optimization
- **List All Todos**: Uses idx_todos_created_at for fast sorting
- **Filter by Status**: Uses idx_todos_completed for fast filtering
- **Get by ID**: Uses primary key index (automatic)

### Scalability
- **Target**: Support up to 1000 todos without degradation (spec.md SC-006)
- **Current Design**: Adequate for target scale
- **Phase III**: Consider pagination, virtual scrolling, archiving

### Connection Pooling
- **SQLModel/SQLAlchemy**: Built-in connection pooling
- **Configuration**: Set pool_size and max_overflow in database.py
- **Recommended**: pool_size=5, max_overflow=10 for MVP

## Testing Strategy

### Model Tests
```python
# Test todo creation
def test_create_todo():
    todo = Todo(title="Buy groceries", description="Milk, eggs, bread")
    assert todo.title == "Buy groceries"
    assert todo.completed == False
    assert todo.created_at is not None

# Test validation
def test_title_required():
    with pytest.raises(ValidationError):
        Todo(title="")  # Should fail

# Test timestamp behavior
def test_updated_at_changes():
    todo = Todo(title="Test")
    original_updated_at = todo.updated_at
    todo.title = "Updated"
    assert todo.updated_at > original_updated_at
```

## Compliance

### Phase II Constitution
- ✅ **Principle II**: Uses Neon PostgreSQL (not in-memory)
- ✅ **Principle VI**: Uses SQLModel (approved ORM)
- ✅ **Principle IX**: Enforces data integrity with constraints
- ✅ **No Phase I Patterns**: No positional indexes, uses database primary keys

### Specification Alignment
- ✅ **FR-001**: Supports title (required) and description (optional)
- ✅ **FR-002**: Persists to database (survives restarts)
- ✅ **FR-004**: Supports completed status
- ✅ **FR-007**: Validates title length (1-200 characters)
- ✅ **FR-008**: Validates description length (max 2000 characters)
- ✅ **FR-012**: Assigns unique identifier (id)
- ✅ **FR-013**: Tracks created_at and updated_at timestamps

## References

- [SQLModel Documentation](https://sqlmodel.tiangolo.com/)
- [Alembic Documentation](https://alembic.sqlalchemy.org/)
- [Pydantic Validation](https://docs.pydantic.dev/latest/concepts/validators/)
- [PostgreSQL Data Types](https://www.postgresql.org/docs/current/datatype.html)

## Conclusion

The Todo data model provides a solid foundation for Phase II implementation. It supports all user stories, enforces validation rules, and follows Phase II Constitution requirements. The model is simple, performant, and ready for implementation.
