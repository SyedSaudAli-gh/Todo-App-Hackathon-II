# Implementation Plan: Dynamic Profile Statistics

**Branch**: `004-dynamic-profile-stats` | **Date**: 2026-01-12 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/004-dynamic-profile-stats/spec.md`

## Summary

Replace static profile statistics with real-time, backend-calculated user activity metrics. The system will fetch authenticated user statistics (total tasks, completed tasks, completion rate, active days) from a new FastAPI endpoint and display them in the existing ProfileStats component. This ensures data accuracy, user isolation, and proper separation of concerns between frontend and backend.

**Technical Approach**: Backend-first implementation with authenticated API endpoint, database queries filtered by user_id, and frontend integration via cookie-based session authentication.

## Technical Context

**Project Type**: Phase II Full-Stack Web Application

### Phase II Full-Stack Web Application

**Frontend**:
- Framework: Next.js 15+ with App Router
- UI Library: React 19+ with hooks
- Language: TypeScript 5+ (strict mode)
- Styling: Tailwind CSS 3+
- State Management: React hooks (useState, useEffect)
- HTTP Client: fetch API
- Authentication: Better Auth (cookie-based sessions)
- Deployment: Vercel

**Backend**:
- Framework: FastAPI 0.100+
- Language: Python 3.13+
- Validation: Pydantic v2
- ORM: SQLModel (SQLAlchemy + Pydantic)
- Migrations: Alembic
- Documentation: OpenAPI/Swagger (auto-generated)
- Deployment: Railway/Render

**Database**:
- Database: Neon PostgreSQL (serverless)
- ORM: SQLModel
- Migrations: Alembic
- Primary Keys: Auto-increment integers
- Relationships: Foreign keys with CASCADE

**Authentication**:
- Frontend: Better Auth with SQLite (auth.db)
- Backend: Session validation via Better Auth cookies
- User Identification: User ID from Better Auth session

**Testing**:
- Frontend: Jest, React Testing Library
- Backend: pytest, FastAPI TestClient
- API: OpenAPI contract validation

### Performance Goals
- API response time: <500ms p95 for stats endpoint
- Database query optimization: Single query for all statistics
- Frontend rendering: <100ms after data received
- Concurrent users: Support 100+ simultaneous requests

### Constraints
- Must not modify ProfileStats component UI/layout
- Must use cookie-based authentication (Better Auth sessions)
- Must calculate all statistics on backend (no frontend calculations)
- Must use UTC for all date/time operations
- Must handle division by zero gracefully (0% completion rate)
- Must filter all queries strictly by authenticated user_id

### Scale/Scope
- Expected users: 100-1000 concurrent users
- Expected todos per user: Up to 1000 todos
- Statistics refresh: On page load/refresh (no real-time updates)
- Error handling: Graceful degradation with user-friendly messages

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Phase II Requirements
- ✅ Uses approved technology stack (Next.js, FastAPI, Neon PostgreSQL)
- ✅ API-first architecture (Frontend → API → Database)
- ✅ Frontend-backend separation (no direct DB access from frontend)
- ✅ Persistent storage (Neon PostgreSQL for todos, Better Auth SQLite for users)
- ✅ No Phase I patterns (no in-memory storage, no CLI, no positional indexes)
- ✅ Database migrations with Alembic (for user_id addition to todos table)
- ✅ OpenAPI/Swagger documentation (auto-generated by FastAPI)
- ✅ Proper error handling and validation (Pydantic models, HTTP status codes)
- ✅ Cookie-based authentication (Better Auth sessions)
- ✅ User data isolation (strict user_id filtering)

**Status**: ✅ All Phase II requirements satisfied

## Project Structure

### Documentation (this feature)

```text
specs/004-dynamic-profile-stats/
├── spec.md              # Feature specification (completed)
├── plan.md              # This file (implementation plan)
├── research.md          # Phase 0 output (to be created)
├── data-model.md        # Phase 1 output (to be created)
├── quickstart.md        # Phase 1 output (to be created)
├── contracts/           # Phase 1 output (to be created)
│   └── user-stats-api.yaml
├── checklists/
│   └── requirements.md  # Specification quality checklist (completed)
└── tasks.md             # Phase 2 output (created by /sp.tasks command)
```

### Source Code (repository root)

```text
api/                          # FastAPI backend
├── src/
│   ├── models/              # SQLModel database models
│   │   ├── __init__.py
│   │   ├── todo.py          # [MODIFY] Add user_id field
│   │   └── user_stats.py    # [NEW] User statistics response model
│   ├── schemas/             # Pydantic request/response models
│   │   ├── __init__.py
│   │   └── user_stats.py    # [NEW] UserStatsResponse schema
│   ├── routers/             # API endpoints
│   │   ├── __init__.py
│   │   ├── health.py        # [EXISTING] Health check
│   │   ├── todos.py         # [EXISTING] Todo CRUD
│   │   └── users.py         # [NEW] User statistics endpoint
│   ├── services/            # Business logic
│   │   ├── __init__.py
│   │   └── stats_service.py # [NEW] Statistics calculation logic
│   ├── middleware/          # Custom middleware
│   │   ├── __init__.py
│   │   └── auth.py          # [NEW] Better Auth session validation
│   ├── database.py          # [EXISTING] Database connection
│   ├── config.py            # [EXISTING] Configuration
│   └── main.py              # [MODIFY] Register users router
├── alembic/                 # Database migrations
│   └── versions/
│       └── [timestamp]_add_user_id_to_todos.py  # [NEW] Migration
├── tests/
│   ├── test_api/
│   │   └── test_user_stats.py  # [NEW] Stats endpoint tests
│   ├── test_services/
│   │   └── test_stats_service.py  # [NEW] Stats service tests
│   └── conftest.py          # [MODIFY] Add auth fixtures
└── requirements.txt         # [EXISTING] Dependencies

web/                          # Next.js frontend
├── src/
│   ├── app/
│   │   └── dashboard/
│   │       └── profile/
│   │           └── page.tsx  # [MODIFY] Replace local stats with API call
│   ├── components/
│   │   └── profile/
│   │       └── ProfileStats.tsx  # [EXISTING] No changes needed
│   ├── lib/
│   │   ├── api/
│   │   │   └── user-stats.ts  # [NEW] API client for stats endpoint
│   │   └── auth/
│   │       ├── auth.ts        # [EXISTING] Better Auth config
│   │       └── auth-client.ts # [EXISTING] Auth client
│   └── types/
│       └── user-stats.ts      # [NEW] TypeScript types for stats
├── tests/
│   ├── unit/
│   │   └── profile-page.test.tsx  # [NEW] Profile page tests
│   └── e2e/
│       └── profile-stats.spec.ts  # [NEW] E2E tests
└── package.json              # [EXISTING] Dependencies
```

**Structure Decision**: Phase II full-stack web application with clear separation between frontend (Next.js) and backend (FastAPI). Authentication handled by Better Auth on frontend, with session validation middleware on backend. Statistics calculated in backend service layer and exposed via REST API.

## Complexity Tracking

> No Constitution Check violations - all requirements satisfied.

## Phase 0: Research & Analysis

### Research Tasks

#### 1. Better Auth Session Validation in FastAPI
**Question**: How to validate Better Auth cookie sessions in FastAPI middleware?

**Research Areas**:
- Better Auth session token format and validation
- Cookie extraction in FastAPI
- Session verification without direct database access
- User ID extraction from validated session

**Expected Outcome**: Middleware implementation pattern for authenticating requests

#### 2. User ID Association Strategy
**Question**: How to associate Better Auth users with FastAPI todos?

**Research Areas**:
- Better Auth user ID format (UUID vs integer)
- Foreign key strategy for user_id in todos table
- Migration strategy for existing todos without user_id
- User creation timestamp retrieval from Better Auth

**Expected Outcome**: Data model design for user_id field and migration approach

#### 3. Statistics Calculation Optimization
**Question**: What's the most efficient way to calculate all statistics in a single query?

**Research Areas**:
- SQLModel aggregation queries (COUNT, SUM)
- Conditional counting for completed tasks
- Date difference calculation in PostgreSQL
- Query performance for 1000+ todos per user

**Expected Outcome**: Optimized SQL query pattern for statistics

#### 4. Error Handling Patterns
**Question**: How to handle edge cases gracefully?

**Research Areas**:
- Division by zero handling (0% completion rate)
- Unauthenticated request handling (401 responses)
- Database connection failures
- Missing user data scenarios

**Expected Outcome**: Error handling strategy and HTTP status code mapping

### Analysis Tasks

#### 1. Existing Code Audit
**Scope**: Review current implementation

**Files to Analyze**:
- `web/src/app/dashboard/profile/page.tsx` - Current stats calculation
- `web/src/components/profile/ProfileStats.tsx` - Component interface
- `api/src/models/todo.py` - Todo model structure
- `web/src/lib/auth/auth.ts` - Better Auth configuration

**Findings**:
- ProfileStats component already accepts correct props (no changes needed)
- Current stats calculated on frontend using local storage (must replace)
- Todo model lacks user_id field (must add with migration)
- Better Auth uses SQLite database (auth.db) separate from Neon PostgreSQL

#### 2. Database Schema Analysis
**Scope**: Determine required schema changes

**Current State**:
- `todos` table: id, title, description, completed, created_at, updated_at
- No user_id field (critical missing piece)
- Better Auth `user` table in separate SQLite database

**Required Changes**:
- Add `user_id` field to `todos` table (string/UUID to match Better Auth)
- Add foreign key constraint (optional, since users are in separate DB)
- Create migration script with Alembic
- Handle existing todos (assign to null or default user)

#### 3. Authentication Flow Analysis
**Scope**: Understand Better Auth → FastAPI authentication

**Current Flow**:
1. User authenticates via Better Auth (frontend)
2. Better Auth sets session cookie
3. Frontend makes API requests with cookie
4. Backend needs to validate cookie and extract user_id

**Required Implementation**:
- FastAPI middleware to read Better Auth session cookie
- Session validation logic (verify signature, check expiration)
- User ID extraction from validated session
- Dependency injection for authenticated user in endpoints

## Phase 1: Design & Contracts

### Data Model Design

**File**: `specs/004-dynamic-profile-stats/data-model.md`

#### Entity: UserStats (Response Model)
**Purpose**: Aggregated statistics for a single user

**Fields**:
- `total_tasks` (integer): Count of all todos for user
- `completed_tasks` (integer): Count of completed todos
- `completion_rate` (float): Percentage (0-100)
- `active_days` (integer): Days since user creation

**Validation Rules**:
- All fields non-negative
- completion_rate between 0 and 100
- active_days >= 1 (inclusive counting)

**Relationships**: None (computed aggregation)

#### Entity: Todo (Modified)
**Purpose**: User's todo item with ownership

**New Field**:
- `user_id` (string): Better Auth user identifier

**Migration Strategy**:
- Add nullable user_id column
- Backfill existing todos (assign to default user or leave null)
- Make user_id required for new todos

### API Contract Design

**File**: `specs/004-dynamic-profile-stats/contracts/user-stats-api.yaml`

#### Endpoint: GET /api/v1/users/me/stats

**Request**:
- Method: GET
- Path: `/api/v1/users/me/stats`
- Headers: Cookie (Better Auth session)
- Body: None
- Query Parameters: None

**Response (200 OK)**:
```json
{
  "total_tasks": 10,
  "completed_tasks": 7,
  "completion_rate": 70.0,
  "active_days": 15
}
```

**Response (401 Unauthorized)**:
```json
{
  "detail": "Not authenticated"
}
```

**Response (500 Internal Server Error)**:
```json
{
  "detail": "Failed to calculate statistics"
}
```

**OpenAPI Schema**:
- Automatic generation via FastAPI
- Available at `/api/v1/docs`
- Includes authentication requirements

### Frontend Integration Design

**File**: `specs/004-dynamic-profile-stats/quickstart.md`

#### API Client Implementation
**File**: `web/src/lib/api/user-stats.ts`

```typescript
export async function getUserStats(): Promise<UserStats> {
  const response = await fetch('/api/v1/users/me/stats', {
    credentials: 'include', // Include cookies
  });

  if (!response.ok) {
    throw new Error('Failed to fetch user statistics');
  }

  return response.json();
}
```

#### Profile Page Integration
**File**: `web/src/app/dashboard/profile/page.tsx`

**Changes**:
1. Remove local stats calculation (`calculateStats` function)
2. Add API call to fetch stats from backend
3. Add loading state while fetching
4. Add error state for failed requests
5. Pass API response directly to ProfileStats component

**State Management**:
- `stats` (UserStats | null): Statistics from API
- `isLoadingStats` (boolean): Loading state
- `statsError` (string | null): Error message

## Phase 2: Implementation Phases

### Phase 1: Database Migration
**Goal**: Add user_id field to todos table

**Tasks**:
1. Create Alembic migration script
2. Add user_id column (nullable string)
3. Add index on user_id for query performance
4. Test migration up/down
5. Apply migration to development database

**Acceptance Criteria**:
- Migration runs without errors
- user_id column exists in todos table
- Existing todos remain intact
- Rollback works correctly

### Phase 2: Backend Service Layer
**Goal**: Implement statistics calculation logic

**Tasks**:
1. Create `stats_service.py` with calculation functions
2. Implement `calculate_total_tasks(user_id)` query
3. Implement `calculate_completed_tasks(user_id)` query
4. Implement `calculate_completion_rate(total, completed)` logic
5. Implement `calculate_active_days(user_created_at)` logic
6. Handle edge cases (zero todos, division by zero)
7. Write unit tests for all functions

**Acceptance Criteria**:
- All statistics calculated correctly
- Zero todos returns 0% completion rate (no errors)
- Active days calculated inclusively (today = day 1)
- All tests pass

### Phase 3: Authentication Middleware
**Goal**: Validate Better Auth sessions in FastAPI

**Tasks**:
1. Create `auth.py` middleware
2. Extract session cookie from request
3. Validate session token
4. Extract user_id from session
5. Create dependency for authenticated user
6. Handle unauthenticated requests (401)
7. Write tests for auth middleware

**Acceptance Criteria**:
- Valid sessions authenticated successfully
- Invalid sessions return 401
- User ID extracted correctly
- Dependency injection works in endpoints

### Phase 4: API Endpoint
**Goal**: Expose user statistics via REST API

**Tasks**:
1. Create `users.py` router
2. Implement GET /users/me/stats endpoint
3. Use auth dependency to get user_id
4. Call stats service to calculate statistics
5. Return UserStatsResponse schema
6. Handle errors (401, 500)
7. Register router in main.py
8. Write API tests

**Acceptance Criteria**:
- Endpoint returns correct statistics
- Authentication required (401 if not authenticated)
- OpenAPI documentation generated
- All tests pass

### Phase 5: Frontend Integration
**Goal**: Replace local stats with API call

**Tasks**:
1. Create `user-stats.ts` API client
2. Create `UserStats` TypeScript type
3. Update profile page to call API
4. Add loading state during fetch
5. Add error handling for failed requests
6. Remove local stats calculation
7. Test with real data

**Acceptance Criteria**:
- Profile page fetches stats from API
- Loading state displayed during fetch
- Error message shown on failure
- Statistics display correctly
- No local calculation code remains

### Phase 6: Testing & Validation
**Goal**: Verify end-to-end functionality

**Tasks**:
1. Test with zero todos (0% completion rate)
2. Test with partial completion (various percentages)
3. Test with full completion (100%)
4. Test with multiple users (data isolation)
5. Test unauthenticated access (401 error)
6. Test API via Swagger UI
7. Test frontend error handling
8. Performance test (1000 todos)

**Acceptance Criteria**:
- All edge cases handled correctly
- No cross-user data leakage
- API response time <500ms
- Frontend displays errors gracefully
- All acceptance scenarios from spec pass

## Technical Decisions

### Decision 1: User ID Storage Strategy
**Decision**: Store user_id as string in todos table to match Better Auth UUID format

**Rationale**:
- Better Auth uses UUID for user identification
- String type provides flexibility for different ID formats
- No foreign key constraint needed (users in separate database)

**Alternatives Considered**:
- Integer user_id: Rejected (Better Auth uses UUID)
- Separate user table in Neon: Rejected (duplicates Better Auth data)

### Decision 2: Authentication Approach
**Decision**: Validate Better Auth session cookies in FastAPI middleware

**Rationale**:
- Cookie-based authentication required by spec
- Middleware provides centralized auth logic
- Dependency injection simplifies endpoint code

**Alternatives Considered**:
- JWT tokens: Rejected (not cookie-based)
- Direct database validation: Rejected (couples to Better Auth internals)

### Decision 3: Statistics Calculation Location
**Decision**: Calculate all statistics in backend service layer

**Rationale**:
- Required by spec (FR-010)
- Ensures data accuracy and consistency
- Enables future caching and optimization
- Prevents frontend manipulation

**Alternatives Considered**:
- Frontend calculation: Rejected (violates spec)
- Database views: Rejected (less flexible)

### Decision 4: Active Days Calculation
**Decision**: Calculate from user.created_at in Better Auth database

**Rationale**:
- User creation date is authoritative source
- Inclusive counting (today = day 1)
- UTC timezone for consistency

**Alternatives Considered**:
- First todo creation date: Rejected (not accurate for join date)
- Activity events: Rejected (spec requires join date)

### Decision 5: Error Handling Strategy
**Decision**: Return appropriate HTTP status codes with JSON error messages

**Rationale**:
- RESTful convention
- Frontend can handle errors gracefully
- User-friendly error messages

**Status Codes**:
- 200: Success
- 401: Unauthenticated
- 500: Server error

## Risk Analysis

### Risk 1: Better Auth Session Validation Complexity
**Impact**: High
**Probability**: Medium
**Mitigation**: Research Better Auth session format early, create proof-of-concept middleware

### Risk 2: User ID Mismatch Between Systems
**Impact**: High
**Probability**: Low
**Mitigation**: Validate user_id format matches Better Auth, add integration tests

### Risk 3: Performance with Large Todo Counts
**Impact**: Medium
**Probability**: Low
**Mitigation**: Optimize queries with indexes, test with 1000+ todos

### Risk 4: Migration of Existing Todos
**Impact**: Medium
**Probability**: Medium
**Mitigation**: Make user_id nullable initially, plan backfill strategy

## Dependencies

### External Dependencies
- Better Auth session validation library (if available)
- Existing Better Auth configuration
- Neon PostgreSQL database access
- Alembic migration system

### Internal Dependencies
- Existing Todo model
- Existing ProfileStats component
- Existing authentication system
- Existing API infrastructure

### Blocking Dependencies
- None (all dependencies already in place)

## Success Metrics

### Performance Metrics
- API response time: <500ms p95
- Database query time: <200ms
- Frontend render time: <100ms after data received

### Quality Metrics
- Test coverage: >80% for new code
- Zero cross-user data leakage
- Zero division by zero errors
- 100% of edge cases handled

### User Experience Metrics
- Statistics load within 2 seconds
- Error messages clear and actionable
- No UI layout changes (preserves existing design)

## Next Steps

1. **Complete Phase 0 Research** (create research.md)
   - Better Auth session validation
   - User ID association strategy
   - Statistics query optimization
   - Error handling patterns

2. **Complete Phase 1 Design** (create data-model.md, contracts/, quickstart.md)
   - Data model documentation
   - OpenAPI contract specification
   - Frontend integration guide

3. **Run /sp.tasks** to generate atomic, testable tasks from this plan

4. **Begin Implementation** following TDD approach (Red-Green-Refactor)

## Appendix

### Glossary
- **Better Auth**: Authentication library used for user management
- **SQLModel**: ORM combining SQLAlchemy and Pydantic
- **Alembic**: Database migration tool for SQLAlchemy
- **Active Days**: Days since user account creation (inclusive)
- **Completion Rate**: Percentage of completed todos (completed / total × 100)

### References
- Feature Specification: `specs/004-dynamic-profile-stats/spec.md`
- Constitution: `.specify/memory/constitution.md`
- Better Auth Documentation: https://better-auth.com
- FastAPI Documentation: https://fastapi.tiangolo.com
- SQLModel Documentation: https://sqlmodel.tiangolo.com
